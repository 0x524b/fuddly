Data Model
**********

.. _vt:value-types:

Value Types
===========

The current types usable within a terminal node are listed in this
section. Each category (``Integer``, ``String``, ``BitField``)
supports different parameters that allows to more accurately specify a
data model, which enables ``fuddly`` to perform more enhanced fuzzing.

.. note:: These parameters will be especially leveraged by the generic
   disruptor ``tTYPE``
   (:class:`fuzzfmk.generic_data_makers.d_fuzz_typed_nodes`). Refer to
   :ref:`dis:generic-disruptors` for more information on it, and to
   :ref:`tuto:disruptors`, for how to create your own *disruptors*.


Integer
-------

All integer types listed below provide the same interface
(:class:`fuzzfmk.value_types.INT`). Their constructor take the
following parameters:

``int_list`` [optional, default value: **None**]
  List of the integers that are considered valid for the node backed
  by this *Integer object*.

``mini`` [optional, default value: **None**]
  Minimum valid value for the node backed by this *Integer object*.

``maxi`` [optional, default value: **None**]
  Maximum valid value for the node backed by this *Integer object*.

``determinist`` [default value: **True**]
  If set to ``True`` generated values will be in a deterministic
  order, otherwise in a random order.


All these parameters are optional. If you don't specify all of them
the constructor will let more freedom within the data model. But if
you have accurate information, don't hesitate to add them in the data
model, as it does not weaken the test cases that will be generated by
the generic disruptors, quite the opposite.

Below the different currently defined integer types, and the
corresponding outputs for a data generated from them:

- :class:`fuzzfmk.value_types.UINT8`: unsigned integer on 8 bit
- :class:`fuzzfmk.value_types.SINT8`: signed integer on 8 bit (2's complement)
- :class:`fuzzfmk.value_types.UINT16_be`: unsigned integer on 16 bit, big endian
- :class:`fuzzfmk.value_types.UINT16_le`: unsigned integer on 16 bit, little endian
- :class:`fuzzfmk.value_types.SINT16_be`: signed integer on 16 bit (2's complement), big endian
- :class:`fuzzfmk.value_types.SINT16_le`: signed integer on 16 bit (2's complement), little endian
- :class:`fuzzfmk.value_types.UINT32_be`: unsigned integer on 32 bit, big endian
- :class:`fuzzfmk.value_types.UINT32_le`: unsigned integer on 32 bit, little endian
- :class:`fuzzfmk.value_types.SINT32_be`: signed integer on 32 bit (2's complement), big endian
- :class:`fuzzfmk.value_types.SINT32_le`: signed integer on 32 bit (2's complement), little endian
- :class:`fuzzfmk.value_types.UINT64_be`: unsigned integer on 64 bit, big endian
- :class:`fuzzfmk.value_types.UINT64_le`: unsigned integer on 64 bit, little endian
- :class:`fuzzfmk.value_types.SINT64_be`: signed integer on 64 bit (2's complement), big endian
- :class:`fuzzfmk.value_types.SINT64_le`: signed integer on 64 bit (2's complement), little endian
- :class:`fuzzfmk.value_types.INT_str`: ASCII encoded integer


String
------

The type :class:`fuzzfmk.value_types.String` takes the following
parameters:

``val_list`` [optional, default value: **None**]
  List of the character strings that are considered valid for the node
  backed by this *String object*.

``size`` [optional, default value: **None**]
  Valid character string size for the node backed by this *String
  object*.

``min_sz`` [optional, default value: **None**]
  Minimum valid size for the character strings for the node backed by
  this *String object*. If not set, this parameter will be
  automatically inferred by looking at the parameter ``val_list``
  whether this latter is provided.

``max_sz`` [optional, default value: **None**]
  Maximum valid size for the character strings for the node backed by this *String
  object*. If not set, this parameter will be
  automatically inferred by looking at the parameter ``val_list``
  whether this latter is provided.

``deteterminist`` [default value: **True**]
  If set to ``True`` generated values will be in a deterministic
  order, otherwise in a random order.

``ascii_mode`` [default value: **False**]
  If set to ``True``, it will enforce the string to comply with ASCII
  7 bits.

``extra_fuzzy_list`` [optional, default value: **None**]
  During data generation, if this parameter is specified with some
  specific values, they will be part of the test cases generated by
  the generic disruptor tTYPE.

``absorb_regexp`` [optional, default value: **None**]
  You can specify a regular expression in this parameter as a
  supplementary constraint for data absorption operation (refer to
  :ref:`tuto:dm-absorption` for more information on that topic).



BitField
--------

The type :class:`fuzzfmk.value_types.BitField` takes the following
parameters:


``subfield_limits`` [optional, default value: **None**]
  List of the limits of each sub-fields (mutually exclusive with
  ``subfield_sizes``), expressed in increasing order. For instance a
  limit list ``[2, 6]`` defines the sub-fields ``0..1`` (2 bits size)
  and ``2..5`` (4 bits size), for a total ``BitField`` size of 6 bits.
  Note that the list begin from the least significant sub-field to the
  more significant sub-field.

``subfield_sizes`` [optional, default value: **None**]
  List of the size of each sub-fields (mutually exclusive with
  ``subfield_limits``), beginning from the least significant sub-field
  to the more significant sub-field.

``subfield_val_lists`` [optional, default value: **None**]
  List of valid values for each sub-fields. Look at the following
  examples for usage.

``subfield_val_extremums`` [optional, default value: **None**]
  List of minimum and maximum value for each sub-fields. Look at the
  following examples for usage.

``padding`` [default value: **0**]
  Should be either set to ``0`` or ``1`` for completion of the
  ``Bitfield`` to a byte boundary if it is not a byte-multiple. Note
  that the method :func:`fuzzfmk.value_types.BitField.extend_right`
  allows to merge two ``BitField`` which could result in padding
  deletion.

``lsb_padding`` [default value: **True**]
  If there is a need for padding, it will be added next to the least
  significant bit if this parameter is set to ``True``, otherwise next
  to the most significant bit. This operation is performed *before*
  endianness encoding.

``endian`` [default value: **VT.LittleEndian**]
  Endianness for *encoding* the BitField.

``determinist`` [default value: **True**]
  If set to ``True`` generated values will be in a deterministic
  order, otherwise in a random order.  Note that in *determinist
  mode*, all the values such a ``BitField`` should be able to generate
  are not covered but only a subset of them (i.e., all combinations
  are not computed). It has been chosen to only keep the value based
  on the following algorithm: "exhaust each subfield one at a
  time". The rationale is that in most cases, computing all
  combinations does not make sense, especially for fuzzing
  purpose. Additionally, note that such nominal generation are not the
  one used by the generic disruptor ``tTYPE`` which rely on
  ``BitField`` *fuzzy mode* (reachable through
  :func:`fuzzfmk.value_types.VT_Alt.switch_mode`).

``subfield_descs`` [optional, default value: **None**]
  List of descriptions (character strings) for each sub-field. To
  describe only part of the sub-fields, put a ``None`` entry for the
  others. This parameter is used for display purpose. Look at the
  following examples for usage.


Let's take the following examples to make ``BitField`` usage
obvious. On the first one, we specify the sub-fields of the
``BitField`` by their limit, and for each sub-field we give either a
list of valid values, or a tuple expressing the minimum and maximum
values. For the purpose of this example we use it directly, without
going through the definition of a data model (for this topic refer to
:ref:`data-model` and :ref:`dm:mydf`):

.. code-block:: python
   :linenos:
   :emphasize-lines: 8-10

    t = BitField(subfield_limits=[2,6,10,12],
	         subfield_val_lists=[[4,2,1], [2,15,16,3], None, [1]],
		 subfield_val_extremums=[None, None, [3,11], None],
		 padding=0, lsb_padding=True, endian=VT.LittleEndian)

    t.pretty_print()

    # output of the previous call:
    #
    #     (+|3: 01 |2: 0100 |1: 1111 |0: 10 |padding: 0000 |-) 19616


Note that the output is the first generated value from your
description. To get another one you will have to call
:func:`fuzzfmk.value_types.BitField.get_value()` on it. Obviously,
this kind of stuff is done automatically for you during a fuzzing
session.


On the second example we specify the sub-fields of the ``BitField`` by
their sizes. And the other parameters are described in the same way as
the first example. We additionally specify the parameter
``subfield_descs``. Look at the output for the differences.

.. code-block:: python
   :linenos:
   :emphasize-lines: 9-11

    t = BitField(subfield_sizes=[4,4,4],
		 subfield_val_lists=[[4,2,1], None, [10,13]],
		 subfield_val_extremums=[None, [14, 15], None],
		 padding=0, lsb_padding=False, endian=VT.BigEndian,
		 subfield_descs=['first', None, 'last'])

    t.pretty_print()

    # output of the previous call:
    #
    #     (+|padding: 0000 |2(last): 1101 |1: 1111 |0(first): 0100 |-) 2788


.. seealso:: Methods are defined to help for modifying a
             :class:`fuzzfmk.value_types.BitField`. If you want to
             deal with ``BitField`` in your specific disruptors, take
             a look especially at:

             - :func:`fuzzfmk.value_types.BitField.set_subfield`, :func:`fuzzfmk.value_types.BitField.get_subfield`
	     - :func:`fuzzfmk.value_types.BitField.extend_right`
	     - :func:`fuzzfmk.value_types.BitField.reset_state`, :func:`fuzzfmk.value_types.BitField.rewind`
	     - :func:`fuzzfmk.value_types.VT_Alt.switch_mode` (used currently by the disruptor ``tTYPE``)




.. _dm:patterns:

Data Model Patterns & Keywords
==============================


How to Describe the Separators Used within a Data Format
--------------------------------------------------------

The example below shows how to define the separators for delimiting
lines of an imaginary data model (line 2-7), and for delimiting
parameters with space characters (line 12-14).

.. code-block:: python
   :linenos:
   :emphasize-lines: 2-7, 12-14

    {'name': 'separator_test',
     'separator': {'contents': {'name': 'sep',
				'contents': String(val_list=['\n'], absorb_regexp=b'[\r\n|\n]+'),
				'absorb_csts': AbsNoCsts(regexp=True)},
		   'prefix': False,
		   'suffix': False,
		   'unique': True},
     'contents': [
	 {'section_type': MH.FullyRandom,
	  'contents': [
	      {'name': 'parameters',
	       'separator': {'contents': {'name': ('sep',2),
					  'contents': String(val_list=[' '], absorb_regexp=b' +'),
					  'absorb_csts': AbsNoCsts(regexp=True)}},
	       'qty': 3,
	       'contents': [
		   {'section_type': MH.FullyRandom,
		    'contents': [
			{'name': 'color',
			'contents': [
			    {'name': 'id',
			     'contents': String(val_list=['color='])},
			    {'name': 'val',
			     'contents': String(val_list=['red', 'black'])}
			]},
			{'name': 'type',
			 'contents': [
			     {'name': ('id', 2),
			      'contents': String(val_list=['type='])},
			     {'name': ('val', 2),
			      'contents': String(val_list=['circle', 'cube', 'rectangle'], determinist=False)}
			]},
		    ]}]},
	      {'contents': String(val_list=['AAAA', 'BBBB', 'CCCC'], determinist=False),
	       'qty': (4, 6),
	       'name': 'str'}
	  ]}
     ]}


From this data model you could get a data like that:

.. code-block:: none

   CCCC
   BBBB
    type=circle color=red 
    type=rectangle color=red 
   BBBB
   AAAA
   CCCC
    color=red type=cube

.. note:: Note this data model can be used to absorb data samples
          (refer to :ref:`tuto:dm-absorption`) that may use more than
          one empty line as first-level separator (thanks to the
          ``absorb_regexp`` parameter in line 3), and more than one
          space character as second-level separators (thanks to the
          ``absorb_regexp`` parameter in line 13).

.. note:: You can also perform specific *separator mutation* within a
          disruptor (refer to :ref:`tuto:disruptors`), as separator nodes have
          the specific attribute
          :const:`fuzzfmk.data_model.NodeInternals.Separator` set.
