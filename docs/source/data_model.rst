Data Model
**********

.. _vt:value-types:

Value Types
===========

The current types usable within a terminal node are listed in this
section. Each category (``Integer``, ``String``, ``BitField``)
supports different parameters that allows to more accurately specify a
data model, which enables ``fuddly`` to perform more enhanced fuzzing.

.. note:: These parameters will be especially leveraged by the generic
   disruptor ``tTYPE``
   (:class:`fuzzfmk.generic_data_makers.d_fuzz_typed_nodes`). Refer to
   :ref:`dis:generic-disruptors` for more information on it, and to
   :ref:`tuto:disruptors`, for how to create your own *disruptors*.


.. _vt:integer:

Integer
-------

All integer types listed below provide the same interface
(:class:`fuzzfmk.value_types.INT`). Their constructor take the
following parameters:

``int_list`` [optional, default value: **None**]
  List of the integers that are considered valid for the node backed
  by this *Integer object*.

``mini`` [optional, default value: **None**]
  Minimum valid value for the node backed by this *Integer object*.

``maxi`` [optional, default value: **None**]
  Maximum valid value for the node backed by this *Integer object*.

``determinist`` [default value: **True**]
  If set to ``True`` generated values will be in a deterministic
  order, otherwise in a random order.


All these parameters are optional. If you don't specify all of them
the constructor will let more freedom within the data model. But if
you have accurate information, don't hesitate to add them in the data
model, as it does not weaken the test cases that will be generated by
the generic disruptors, quite the opposite.

Below the different currently defined integer types, and the
corresponding outputs for a data generated from them:

- :class:`fuzzfmk.value_types.UINT8`: unsigned integer on 8 bit
- :class:`fuzzfmk.value_types.SINT8`: signed integer on 8 bit (2's complement)
- :class:`fuzzfmk.value_types.UINT16_be`: unsigned integer on 16 bit, big endian
- :class:`fuzzfmk.value_types.UINT16_le`: unsigned integer on 16 bit, little endian
- :class:`fuzzfmk.value_types.SINT16_be`: signed integer on 16 bit (2's complement), big endian
- :class:`fuzzfmk.value_types.SINT16_le`: signed integer on 16 bit (2's complement), little endian
- :class:`fuzzfmk.value_types.UINT32_be`: unsigned integer on 32 bit, big endian
- :class:`fuzzfmk.value_types.UINT32_le`: unsigned integer on 32 bit, little endian
- :class:`fuzzfmk.value_types.SINT32_be`: signed integer on 32 bit (2's complement), big endian
- :class:`fuzzfmk.value_types.SINT32_le`: signed integer on 32 bit (2's complement), little endian
- :class:`fuzzfmk.value_types.UINT64_be`: unsigned integer on 64 bit, big endian
- :class:`fuzzfmk.value_types.UINT64_le`: unsigned integer on 64 bit, little endian
- :class:`fuzzfmk.value_types.SINT64_be`: signed integer on 64 bit (2's complement), big endian
- :class:`fuzzfmk.value_types.SINT64_le`: signed integer on 64 bit (2's complement), little endian
- :class:`fuzzfmk.value_types.INT_str`: ASCII encoded integer


String
------

The type :class:`fuzzfmk.value_types.String` takes the following
parameters:

``val_list`` [optional, default value: **None**]
  List of the character strings that are considered valid for the node
  backed by this *String object*.

``size`` [optional, default value: **None**]
  Valid character string size for the node backed by this *String
  object*.

``min_sz`` [optional, default value: **None**]
  Minimum valid size for the character strings for the node backed by
  this *String object*. If not set, this parameter will be
  automatically inferred by looking at the parameter ``val_list``
  whether this latter is provided.

``max_sz`` [optional, default value: **None**]
  Maximum valid size for the character strings for the node backed by this *String
  object*. If not set, this parameter will be
  automatically inferred by looking at the parameter ``val_list``
  whether this latter is provided.

``deteterminist`` [default value: **True**]
  If set to ``True`` generated values will be in a deterministic
  order, otherwise in a random order.

``ascii_mode`` [default value: **False**]
  If set to ``True``, it will enforce the string to comply with ASCII
  7 bits.

``extra_fuzzy_list`` [optional, default value: **None**]
  During data generation, if this parameter is specified with some
  specific values, they will be part of the test cases generated by
  the generic disruptor tTYPE.

``absorb_regexp`` [optional, default value: **None**]
  You can specify a regular expression in this parameter as a
  supplementary constraint for data absorption operation (refer to
  :ref:`tuto:dm-absorption` for more information on that topic).

``alphabet`` [optional, default value: **string.printable**]
  The alphabet to use for generating data, in case no ``val_list`` is
  provided.


BitField
--------

The type :class:`fuzzfmk.value_types.BitField` takes the following
parameters:


``subfield_limits`` [optional, default value: **None**]
  List of the limits of each sub-fields (mutually exclusive with
  ``subfield_sizes``), expressed in increasing order. For instance a
  limit list ``[2, 6]`` defines the sub-fields ``0..1`` (2 bits size)
  and ``2..5`` (4 bits size), for a total ``BitField`` size of 6 bits.
  Note that the list begin from the least significant sub-field to the
  more significant sub-field.

``subfield_sizes`` [optional, default value: **None**]
  List of the size of each sub-fields (mutually exclusive with
  ``subfield_limits``), beginning from the least significant sub-field
  to the more significant sub-field.

``subfield_val_lists`` [optional, default value: **None**]
  List of valid values for each sub-fields. Look at the following
  examples for usage.

``subfield_val_extremums`` [optional, default value: **None**]
  List of minimum and maximum value for each sub-fields. Look at the
  following examples for usage.

``padding`` [default value: **0**]
  Should be either set to ``0`` or ``1`` for completion of the
  ``Bitfield`` to a byte boundary if it is not a byte-multiple. Note
  that the method :func:`fuzzfmk.value_types.BitField.extend_right`
  allows to merge two ``BitField`` which could result in padding
  deletion.

``lsb_padding`` [default value: **True**]
  If there is a need for padding, it will be added next to the least
  significant bit if this parameter is set to ``True``, otherwise next
  to the most significant bit. This operation is performed *before*
  endianness encoding.

``endian`` [default value: **VT.LittleEndian**]
  Endianness for *encoding* the BitField.

``determinist`` [default value: **True**]
  If set to ``True`` generated values will be in a deterministic
  order, otherwise in a random order.  Note that in *determinist
  mode*, all the values such a ``BitField`` should be able to generate
  are not covered but only a subset of them (i.e., all combinations
  are not computed). It has been chosen to only keep the value based
  on the following algorithm: "exhaust each subfield one at a
  time". The rationale is that in most cases, computing all
  combinations does not make sense, especially for fuzzing
  purpose. Additionally, note that such nominal generation are not the
  one used by the generic disruptor ``tTYPE`` which rely on
  ``BitField`` *fuzzy mode* (reachable through
  :func:`fuzzfmk.value_types.VT_Alt.switch_mode`).

``subfield_descs`` [optional, default value: **None**]
  List of descriptions (character strings) for each sub-field. To
  describe only part of the sub-fields, put a ``None`` entry for the
  others. This parameter is used for display purpose. Look at the
  following examples for usage.


Let's take the following examples to make ``BitField`` usage
obvious. On the first one, we specify the sub-fields of the
``BitField`` by their limit, and for each sub-field we give either a
list of valid values, or a tuple expressing the minimum and maximum
values. For the purpose of this example we use it directly, without
going through the definition of a data model (for this topic refer to
:ref:`data-model` and :ref:`dm:mydf`):

.. code-block:: python
   :linenos:
   :emphasize-lines: 8-10

    t = BitField(subfield_limits=[2,6,10,12],
	         subfield_val_lists=[[4,2,1], [2,15,16,3], None, [1]],
		 subfield_val_extremums=[None, None, [3,11], None],
		 padding=0, lsb_padding=True, endian=VT.LittleEndian)

    t.pretty_print()

    # output of the previous call:
    #
    #     (+|3: 01 |2: 0100 |1: 1111 |0: 10 |padding: 0000 |-) 19616


Note that the output is the first generated value from your
description. To get another one you will have to call
:func:`fuzzfmk.value_types.BitField.get_value()` on it. Obviously,
this kind of stuff is done automatically for you during a fuzzing
session.


On the second example we specify the sub-fields of the ``BitField`` by
their sizes. And the other parameters are described in the same way as
the first example. We additionally specify the parameter
``subfield_descs``. Look at the output for the differences.

.. code-block:: python
   :linenos:
   :emphasize-lines: 9-11

    t = BitField(subfield_sizes=[4,4,4],
		 subfield_val_lists=[[4,2,1], None, [10,13]],
		 subfield_val_extremums=[None, [14, 15], None],
		 padding=0, lsb_padding=False, endian=VT.BigEndian,
		 subfield_descs=['first', None, 'last'])

    t.pretty_print()

    # output of the previous call:
    #
    #     (+|padding: 0000 |2(last): 1101 |1: 1111 |0(first): 0100 |-) 2788


.. seealso:: Methods are defined to help for modifying a
             :class:`fuzzfmk.value_types.BitField`. If you want to
             deal with ``BitField`` in your specific disruptors, take
             a look especially at:

             - :func:`fuzzfmk.value_types.BitField.set_subfield`, :func:`fuzzfmk.value_types.BitField.get_subfield`
	     - :func:`fuzzfmk.value_types.BitField.extend_right`
	     - :func:`fuzzfmk.value_types.BitField.reset_state`, :func:`fuzzfmk.value_types.BitField.rewind`
	     - :func:`fuzzfmk.value_types.VT_Alt.switch_mode` (used currently by the disruptor ``tTYPE``)




.. _dm:patterns:

Data Model Patterns & Keywords
==============================


How to Describe the Separators Used within a Data Format
--------------------------------------------------------

The example below shows how to define the separators for delimiting
lines of an imaginary data model (line 2-7), and for delimiting
parameters with space characters (line 12-14).

.. code-block:: python
   :linenos:
   :emphasize-lines: 2-7, 12-14

    {'name': 'separator_test',
     'separator': {'contents': {'name': 'sep',
				'contents': String(val_list=['\n'], absorb_regexp=b'[\r\n|\n]+'),
				'absorb_csts': AbsNoCsts(regexp=True)},
		   'prefix': False,
		   'suffix': False,
		   'unique': True},
     'contents': [
	 {'section_type': MH.FullyRandom,
	  'contents': [
	      {'name': 'parameters',
	       'separator': {'contents': {'name': ('sep',2),
					  'contents': String(val_list=[' '], absorb_regexp=b' +'),
					  'absorb_csts': AbsNoCsts(regexp=True)}},
	       'qty': 3,
	       'contents': [
		   {'section_type': MH.FullyRandom,
		    'contents': [
			{'name': 'color',
			'contents': [
			    {'name': 'id',
			     'contents': String(val_list=['color='])},
			    {'name': 'val',
			     'contents': String(val_list=['red', 'black'])}
			]},
			{'name': 'type',
			 'contents': [
			     {'name': ('id', 2),
			      'contents': String(val_list=['type='])},
			     {'name': ('val', 2),
			      'contents': String(val_list=['circle', 'cube', 'rectangle'], determinist=False)}
			]},
		    ]}]},
	      {'contents': String(val_list=['AAAA', 'BBBB', 'CCCC'], determinist=False),
	       'qty': (4, 6),
	       'name': 'str'}
	  ]}
     ]}


From this data model you could get a data like that:

.. code-block:: none

   CCCC
   BBBB
    type=circle color=red 
    type=rectangle color=red 
   BBBB
   AAAA
   CCCC
    color=red type=cube

.. note:: Note this data model can be used to absorb data samples
          (refer to :ref:`tuto:dm-absorption`) that may use more than
          one empty line as first-level separator (thanks to the
          ``absorb_regexp`` parameter in line 3), and more than one
          space character as second-level separators (thanks to the
          ``absorb_regexp`` parameter in line 13).

.. note:: You can also perform specific *separator mutation* within a
          disruptor (refer to :ref:`tuto:disruptors`), as separator nodes have
          the specific attribute
          :const:`fuzzfmk.data_model.NodeInternals.Separator` set.


How to Describe a Data Format Whose Parts Change Depending on Some Fields
-------------------------------------------------------------------------

The example below shows how to define a data format based on *opcodes*
and *sub-opcodes* which change the form of the data itself. We use for
that purpose the keyword ``exists_if`` with some subclasses of
:class:`fuzzfmk.data_model.NodeCondition` and node references. 

.. note:: The keyword ``exists_if`` can directly take a node
          reference. In such case, the condition is the existence of
          this node itself.

.. code-block:: python
   :linenos:
   :emphasize-lines: 9, 14, 17, 29, 33, 39, 43

    {'name': 'exist_cond',
     'shape_type': MH.Ordered,
     'contents': [
	 {'name': 'opcode',
	  'contents': String(val_list=['A1', 'A2', 'A3'], determinist=True)},

	 {'name': 'command_A1',
	  'contents': String(val_list=['AAA', 'BBBB', 'CCCCC']),
	  'exists_if': (RawCondition('A1'), 'opcode'),
	  'qty': 3},

	 {'name': 'command_A2',
	  'contents': UINT32_be(int_list=[0xDEAD, 0xBEEF]),
	  'exists_if': (RawCondition('A2'), 'opcode')},

	 {'name': 'command_A3',
	  'exists_if': (RawCondition('A3'), 'opcode'),
	  'contents': [
	      {'name': 'A3_subopcode',
	       'contents': BitField(subfield_sizes=[15,2,4], endian=VT.BigEndian,
				    subfield_val_lists=[None, [1,2], [5,6,12]],
				    subfield_val_extremums=[[500, 600], None, None],
				    determinist=False)},

	      {'name': 'A3_int',
	       'contents': UINT16_be(int_list=[10, 20, 30], determinist=False)},

	      {'name': 'A3_deco1',
	       'exists_if': (IntCondition(10), 'A3_int'),
	       'contents': String(val_list=['*1*0*'])},

	      {'name': 'A3_deco2',
	       'exists_if': (IntCondition([20, 30]), 'A3_int'),
	       'contents': String(val_list=['+2+0+3+0+'])}
	  ]},

	 {'name': 'A31_payload',
	  'contents': String(val_list=['$ A31_OK $', '$ A31_KO $'], determinist=False),
	  'exists_if': (BitFieldCondition(sf=2, val=[6,12]), 'A3_subopcode')},

	 {'name': 'A32_payload',
	  'contents': String(val_list=['$ A32_VALID $', '$ A32_INVALID $'], determinist=False),
	  'exists_if': (BitFieldCondition(sf=2, val=5), 'A3_subopcode')}
     ]}


Example of data generated by such a data model are presented below (in ASCII art):

.. code-block:: none

   [0] exist_cond [NonTerm]
    \__(1) exist_cond/opcode [String] size=2B
    |        \_raw: 'A3'
    \__[1] exist_cond/command_A3 [NonTerm]
    |   \__(2) exist_cond/command_A3/A3_subopcode [BitField] size=3B
    |   |        \_ (+|2: 0110 |1: 01 |0: 000001001001001 |padding: 000 |-) 6558280
    |   |        \_raw: 'd\x12H'
    |   \__(2) exist_cond/command_A3/A3_int [UINT16_be] size=2B
    |   |        \_ 10 (0xA)
    |   |        \_raw: '\x00\n'
    |   \__(2) exist_cond/command_A3/A3_deco1 [String] size=5B
    |            \_raw: '*1*0*'
    \__(1) exist_cond/A31_payload [String] size=10B
	     \_raw: '$ A31_OK $'


   [0] exist_cond [NonTerm]
    \__(1) exist_cond/opcode [String] size=2B
    |        \_raw: 'A1'
    \__(1) exist_cond/command_A1 [String] size=3B
    |        \_raw: 'AAA'
    \__(1) exist_cond/command_A1:2 [String] size=3B
    |        \_raw: 'AAA'
    \__(1) exist_cond/command_A1:3 [String] size=3B
	     \_raw: 'AAA'


   [0] exist_cond [NonTerm]
    \__(1) exist_cond/opcode [String] size=2B
    |        \_raw: 'A2'
    \__(1) exist_cond/command_A2 [UINT32_be] size=4B
	     \_ 48879 (0xBEEF)
	     \_raw: '\x00\x00\xbe\xef'


.. note:: Note this data model can be used for generating data and
          also (without modification) for absorbing data samples that
          comply to its grammar (refer to :ref:`tuto:dm-absorption`)


How to Generate Nodes Dynamically (for length, counter, ...)
------------------------------------------------------------

The example below shows how to describe a node that will dynamically
generate a node containing the length of another one, a variable
character string in our case.

.. code-block:: python
   :linenos:
   :emphasize-lines: 5-6

    {'name': 'len_gen',
     'contents': [
	 {'name': 'len',
	  'type': MH.Generator,
	  'contents': lambda x: Node('cts', value_type= \
                                     UINT32_be(int_list=[len(x.to_bytes())])),
	  'node_args': 'payload'},

	 {'name': 'payload',
	  'contents': String(min_sz=10, max_sz=100, determinist=False)},
     ]}

Note the *generator* is just a specific kind of node
(:class:`fuzzfmk.data_model.NodeInternals_GenFunc`) that embeds a
function that returns a node (:class:`fuzzfmk.data_model.Node`). In
the previous description, the function is provided through the keyword
``contents``, and it's a simple lambda function taking a node as
parameter, on which is called
:meth:`fuzzfmk.data_model.Node.to_bytes()` to get its bytes
representation and then the ``len()`` function. The result is used for
defining a terminal node of type
:class:`fuzzfmk.value_types.UINT32_be` (refer to section :ref:`vt:integer`).

This use case can be described by using the specific *generator
template* :meth:`fuzzfmk.data_model_helpers.MH.LEN()` which will basically
return the previous lambda function. The following example makes use
of it.

.. note:: Generator templates are defined as static methods of
          :class:`fuzzfmk.data_model_helpers.MH`. They make the description
          of some generic use cases simpler.

.. code-block:: python
   :linenos:
   :emphasize-lines: 5

    {'name': 'len_gen',
     'contents': [
	 {'name': 'len',
	  'type': MH.Generator,
	  'contents': MH.LEN(UINT32_be),
	  'node_args': 'payload'},

	 {'name': 'payload',
	  'contents': String(min_sz=10, max_sz=100, determinist=False)},
     ]}


To conclude on this use case, note that the previous description can
be used for data generation, but it won't be usable as-is for data
absorption (refer to :ref:`tuto:dm-absorption`). Indeed, the way
absorption works is by walking through the graph and it will reach the
generator first. This one will freeze the string contents by getting
its bytes representation and will create an ``UINT32_be`` node with
only one value, the length of the arbitrarily generated string. This
value will be used for validating the corresponding data part within
the raw data to absorb, as the absorption operation will by default
enforce contents equality. Hence, it will fail. To solve this problem,
the simplest solution is to release some local constraints during
absorption, namely we need to release the ``Contents`` constraint for
the ``len`` node. More simply, we can release all the absorption
constraints for this node, as shown in the following example:

.. code-block:: python
   :linenos:
   :emphasize-lines: 7

    {'name': 'len_gen',
     'contents': [
	 {'name': 'len',
	  'type': MH.Generator,
	  'contents': MH.LEN(UINT32_be),
	  'node_args': 'payload',
	  'absorb_csts': AbsNoCsts()  # or more accurately AbsCsts(contents=False)
	  },

	 {'name': 'payload',
	  'contents': String(min_sz=10, max_sz=100, determinist=False)},
     ]}

Another solution can be to define an alternate configuration that will
be used only for absorption:

.. code-block:: python
   :linenos:
   :emphasize-lines: 7-9

    {'name': 'len_gen',
     'contents': [
	 {'name': 'len',
	  'type': MH.Generator,
	  'contents': MH.LEN(UINT32_be),
	  'node_args': 'payload',
	  'alt': [
	      {'conf': 'ABS',
	       'contents': UINT32_be(maxi=100)} ]},

	 {'name': 'payload',
	  'contents': String(min_sz=10, max_sz=100, determinist=False)},
     ]}

This solution is more complex, but can revealed itself to be useful
for more complex situation.

.. seealso:: Look at the example :ref:`ex:zip-mod` to see how to
   change the node configuration before absorption. And for more
   insights on that topic refer to :ref:`data-model` and
   :ref:`tuto:disruptors`.


Finally, let's take the following example that illustrates other
*generator templates*, namely
:meth:`fuzzfmk.data_model_helpers.MH.QTY()`,
:meth:`fuzzfmk.data_model_helpers.MH.CRC()` and
:meth:`fuzzfmk.data_model_helpers.MH.TIMESTAMP()`.

.. code-block:: python
   :linenos:
   :emphasize-lines: 16, 21, 26, 31

    {'name': 'misc_gen',
     'contents': [
	 {'name': 'integers',
	  'contents': [
	      {'name': 'int16',
	       'qty': (2, 10),
	       'contents': UINT16_be(int_list=[16, 1, 6], determinist=False)},

	      {'name': 'int32',
	       'qty': (3, 8),
	       'contents': UINT32_be(int_list=[32, 3, 2], determinist=False)}
	  ]},

	 {'name': 'int16_qty',
	  'type': MH.Generator,
	  'contents': MH.QTY(node_name='int16', vt=UINT8),
	  'node_args': 'integers'},

	 {'name': 'int32_qty',
	  'type': MH.Generator,
	  'contents': MH.QTY(node_name='int32', vt=UINT8),
	  'node_args': 'integers'},

	 {'name': 'tstamp',
	  'type': MH.Generator,
	  'contents': MH.TIMESTAMP("%H%M%S"),
	  'absorb_csts': AbsCsts(contents=False)},

	 {'name': 'crc',
	  'type': MH.Generator,
	  'contents': MH.CRC(UINT32_be),
	  'node_args': ['tstamp', 'int32_qty'],
	  'absorb_csts': AbsCsts(contents=False)}
     ]}

.. note:: Note this data model is compatible for *data absorption*.

Here under an example of data generated by such a data model (in ASCII art):

.. code-block:: none

   [0] misc_gen [NonTerm]
    \__[1] misc_gen/integers [NonTerm]
    |   \__(2) misc_gen/integers/int16 [UINT16_be] size=2B
    |   |        \_ 6 (0x6)
    |   |        \_raw: '\x00\x06'
    |   \__(2) misc_gen/integers/int16:2 [UINT16_be] size=2B
    |   |        \_ 1 (0x1)
    |   |        \_raw: '\x00\x01'
    |   \__(2) misc_gen/integers/int16:3 [UINT16_be] size=2B
    |   |        \_ 1 (0x1)
    |   |        \_raw: '\x00\x01'
    |   \__(2) misc_gen/integers/int16:4 [UINT16_be] size=2B
    |   |        \_ 6 (0x6)
    |   |        \_raw: '\x00\x06'
    |   \__(2) misc_gen/integers/int16:5 [UINT16_be] size=2B
    |   |        \_ 6 (0x6)
    |   |        \_raw: '\x00\x06'
    |   \__(2) misc_gen/integers/int16:6 [UINT16_be] size=2B
    |   |        \_ 1 (0x1)
    |   |        \_raw: '\x00\x01'
    |   \__(2) misc_gen/integers/int16:7 [UINT16_be] size=2B
    |   |        \_ 1 (0x1)
    |   |        \_raw: '\x00\x01'
    |   \__(2) misc_gen/integers/int32 [UINT32_be] size=4B
    |   |        \_ 2 (0x2)
    |   |        \_raw: '\x00\x00\x00\x02'
    |   \__(2) misc_gen/integers/int32:2 [UINT32_be] size=4B
    |   |        \_ 3 (0x3)
    |   |        \_raw: '\x00\x00\x00\x03'
    |   \__(2) misc_gen/integers/int32:3 [UINT32_be] size=4B
    |            \_ 2 (0x2)
    |            \_raw: '\x00\x00\x00\x02'
    \__[1] misc_gen/int16_qty [GenFunc | node_args: misc_gen/integers]
    |   \__(2) misc_gen/int16_qty/cts [UINT8] size=1B
    |            \_ 7 (0x7)
    |            \_raw: '\x07'
    \__[1] misc_gen/int32_qty [GenFunc | node_args: misc_gen/integers]
    |   \__(2) misc_gen/int32_qty/cts [UINT8] size=1B
    |            \_ 3 (0x3)
    |            \_raw: '\x03'
    \__[1] misc_gen/tstamp [GenFunc | node_args: None]
    |   \__(2) misc_gen/tstamp/cts [String] size=6B
    |            \_raw: '170140'
    \__[1] misc_gen/crc [GenFunc | node_args: misc_gen/tstamp, misc_gen/int32_qty]
	\__(2) misc_gen/crc/cts [UINT32_be] size=4B
		 \_ 110906314 (0x69C4BCA)
		 \_raw: '\x06\x9cK\xca'


Which correspond to the following data::

  '\x00\x06\x00\x01\x00\x01\x00\x06\x00\x06\x00\x01\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x02\x07\x03170140\x06\x9cK\xca'
